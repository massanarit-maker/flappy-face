<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Flappy Face</title>
  <style>
    :root{
      --bg1:#0b1220; --bg2:#070c18;
      --panel:#111b33; --panel2:#0f1730;
      --accent:#4f8cff; --text:#fff;
      --muted:rgba(255,255,255,.75);
      --shadow:0 0 50px rgba(0,0,0,.6);
      --radius:18px;
    }
    html,body{ margin:0; padding:0; height:100%; background:var(--bg1); color:var(--text);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      overflow:hidden;
    }
    #gameWrap{ position:relative; width:100vw; height:100vh; }
    canvas#gameCanvas{ display:block; width:100%; height:100%; background:linear-gradient(#101c36, #070c18); }
    .hud{
      position:absolute; top:12px; left:12px; right:12px;
      display:flex; justify-content:space-between; gap:10px; z-index:2;
      pointer-events:none;
    }
    .hud .pill{
      pointer-events:none;
      background:rgba(17,27,51,.75);
      border:1px solid rgba(255,255,255,.08);
      padding:8px 12px; border-radius:999px;
      font-size:13px; box-shadow:var(--shadow);
      backdrop-filter: blur(6px);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width:48vw;
    }

    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(5,10,20,.82); z-index:5;
    }
    .hidden{ display:none !important; }
    .modal{
      width:min(92vw, 720px);
      background:linear-gradient(180deg, rgba(17,27,51,1), rgba(15,23,48,1));
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:18px;
    }
    .title{ font-size:20px; margin:0 0 6px 0; font-weight:700; }
    .small{ font-size:12px; color:var(--muted); line-height:1.35; }
    .grid{ display:grid; grid-template-columns: 1.1fr .9fr; gap:14px; margin-top:12px; }
    @media (max-width: 820px){
      .grid{ grid-template-columns:1fr; }
      .hud .pill{ max-width:60vw; }
    }

    .photoWrap{ position:relative; width:100%; border-radius:14px; overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      aspect-ratio: 16/10;
      display:flex; align-items:center; justify-content:center;
    }
    .photoWrap img{ width:100%; height:100%; object-fit:cover; display:block; }
    .photoWrap canvas{ position:absolute; inset:0; width:100%; height:100%; }
    .panel{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      background:rgba(255,255,255,.03);
    }
    label{ display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    input{
      width:100%; box-sizing:border-box;
      padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.25); color:var(--text);
      outline:none;
      font-size:14px;
    }
    input:focus{ border-color:rgba(79,140,255,.65); }
    .btn{
      width:100%; margin-top:10px;
      padding:12px 14px; border-radius:12px; border:0;
      background:var(--accent); color:#fff; font-weight:700; font-size:15px;
      cursor:pointer;
    }
    .btn:active{ transform: translateY(1px); }
    .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .avatarPreview{
      width:90px; height:90px; border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.25);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    .avatarPreview canvas{ width:100%; height:100%; }
    .err{ margin-top:8px; color:#ffb3b3; font-size:12px; min-height:16px; }

    .gameOverModal{ width:min(92vw, 520px); }
    .lb{
      margin-top:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      max-height:260px; overflow:auto;
    }
    .lbItem{
      display:flex; justify-content:space-between; padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:14px;
    }
    .lbItem:last-child{ border-bottom:0; }
    .hintBar{
      margin-top:10px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      font-size:12px; color:var(--muted);
    }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
      <div class="pill" id="hudLeft">User: Not set</div>
      <div class="pill" id="hudRight">Score: 0 | Best: 0</div>
    </div>

    <!-- SETUP OVERLAY -->
    <div class="overlay" id="setupOverlay">
      <div class="modal">
        <div class="title">Pick Your Face, Enter Your Username</div>
        <div class="small">Drag a box over your face in the family photo. On iPhone, press and drag. Then press Start Game.</div>

        <div class="grid">
          <div class="photoWrap">
            <img id="familyImg" src="family-photo-123.jpg" alt="Family Photo" />
            <canvas id="selector"></canvas>
          </div>

          <div class="panel">
            <label for="username">Username (required)</label>
            <input id="username" placeholder="Type a username" autocomplete="off" />

            <div style="height:10px"></div>

            <div class="row">
              <div>
                <div class="small" style="font-weight:700; margin-bottom:6px;">Avatar preview</div>
                <div class="small">Draw a box on the photo.</div>
              </div>
              <div class="avatarPreview">
                <canvas id="avatarCanvas" width="180" height="180"></canvas>
              </div>
            </div>

            <button class="btn" id="startBtn">Start Game</button>
            <div class="err" id="setupError"></div>

            <div class="hintBar">
              <span>Tap / Click to flap</span>
              <span>Leaderboard shows at Game Over</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- GAME OVER OVERLAY -->
    <div class="overlay hidden" id="gameOverOverlay">
      <div class="modal gameOverModal">
        <div class="title">Game Over</div>
        <div class="small" id="rankText"></div>

        <div class="lb" id="lbBox"></div>

        <button class="btn" id="playAgainBtn">Play Again</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Helpers ----------
  const qs = (s) => document.querySelector(s);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // ---------- Elements ----------
  const gameCanvas = qs("#gameCanvas");
  const g = gameCanvas.getContext("2d");

  const setupOverlay = qs("#setupOverlay");
  const gameOverOverlay = qs("#gameOverOverlay");
  const setupError = qs("#setupError");

  const familyImg = qs("#familyImg");
  const selector = qs("#selector");
  const sctx = selector.getContext("2d");

  const avatarCanvas = qs("#avatarCanvas");
  const actx = avatarCanvas.getContext("2d");

  const usernameInput = qs("#username");
  const startBtn = qs("#startBtn");
  const playAgainBtn = qs("#playAgainBtn");

  const hudLeft = qs("#hudLeft");
  const hudRight = qs("#hudRight");

  const rankText = qs("#rankText");
  const lbBox = qs("#lbBox");

  // ---------- GitHub Pages base handling ----------
  // We are in /flappy-face/ so relative "family-photo-123.jpg" works IF the file is in docs/ root.
  // (Which you have: docs/family-photo-123.jpg)

  // ---------- Leaderboard (LOCAL ONLY on GitHub Pages) ----------
  // Note: This is per-device/browser. Global requires a backend.
  const LB_KEY = "flappyface_scores_v1";
  function loadScores(){
    try { return JSON.parse(localStorage.getItem(LB_KEY) || "{}"); } catch { return {}; }
  }
  function saveBest(user, score){
    const scores = loadScores();
    scores[user] = Math.max(scores[user] || 0, score);
    localStorage.setItem(LB_KEY, JSON.stringify(scores));
    return scores;
  }
  function sortedScores(){
    return Object.entries(loadScores()).sort((a,b)=>b[1]-a[1]);
  }
  function top10(){
    return sortedScores().slice(0,10);
  }

  // ---------- Canvas sizing ----------
  function resizeGame(){
    const dpr = window.devicePixelRatio || 1;
    gameCanvas.width = Math.floor(window.innerWidth * dpr);
    gameCanvas.height = Math.floor(window.innerHeight * dpr);
    gameCanvas.style.width = window.innerWidth + "px";
    gameCanvas.style.height = window.innerHeight + "px";
    g.setTransform(dpr,0,0,dpr,0,0);
  }

  function resizeSelector(){
    const rect = familyImg.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    selector.width = Math.floor(rect.width * dpr);
    selector.height = Math.floor(rect.height * dpr);
    selector.style.width = rect.width + "px";
    selector.style.height = rect.height + "px";
    sctx.setTransform(dpr,0,0,dpr,0,0);
    drawSelection();
  }

  window.addEventListener("resize", () => { resizeGame(); resizeSelector(); });
  resizeGame();

  // ---------- Face selection ----------
  let selBox = null; // in CSS pixels relative to displayed image box
  let dragging = false;
  let startPt = null;

  function clearSelectionCanvas(){
    const rect = familyImg.getBoundingClientRect();
    sctx.clearRect(0,0,rect.width,rect.height);
  }

  function drawSelection(){
    clearSelectionCanvas();
    if(!selBox) return;
    const rect = familyImg.getBoundingClientRect();
    sctx.save();
    sctx.strokeStyle = "#4f8cff";
    sctx.lineWidth = 2;
    sctx.setLineDash([6,4]);
    sctx.strokeRect(selBox.x, selBox.y, selBox.w, selBox.h);
    sctx.restore();
  }

  function updateAvatarPreview(){
    actx.clearRect(0,0,avatarCanvas.width, avatarCanvas.height);
    if(!selBox) {
      // placeholder
      actx.fillStyle = "rgba(255,255,255,.08)";
      actx.fillRect(0,0,avatarCanvas.width, avatarCanvas.height);
      actx.fillStyle = "rgba(255,255,255,.55)";
      actx.font = "bold 18px system-ui";
      actx.textAlign="center"; actx.textBaseline="middle";
      actx.fillText("Select", avatarCanvas.width/2, avatarCanvas.height/2 - 12);
      actx.fillText("a face", avatarCanvas.width/2, avatarCanvas.height/2 + 12);
      return;
    }

    // Convert displayed selection box to natural image coords
    const displayRect = familyImg.getBoundingClientRect();
    const scaleX = familyImg.naturalWidth / displayRect.width;
    const scaleY = familyImg.naturalHeight / displayRect.height;

    const sx = Math.round(selBox.x * scaleX);
    const sy = Math.round(selBox.y * scaleY);
    const sw = Math.round(selBox.w * scaleX);
    const sh = Math.round(selBox.h * scaleY);

    // Draw cropped face into avatar canvas (square)
    const size = avatarCanvas.width;
    actx.save();
    actx.fillStyle = "rgba(0,0,0,.25)";
    actx.fillRect(0,0,size,size);

    // cover-fit crop into square
    const srcAR = sw / sh;
    let cw = sw, ch = sh, cx = sx, cy = sy;
    if(srcAR > 1){
      // wider than tall -> crop width to square
      cw = sh;
      cx = sx + Math.floor((sw - cw)/2);
    } else {
      // taller than wide -> crop height
      ch = sw;
      cy = sy + Math.floor((sh - ch)/2);
    }

    // circle mask
    actx.beginPath();
    actx.arc(size/2, size/2, size*0.48, 0, Math.PI*2);
    actx.clip();

    actx.drawImage(familyImg, cx, cy, cw, ch, 0, 0, size, size);

    actx.restore();
  }

  function pointerPos(e){
    const rect = selector.getBoundingClientRect();
    return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
  }

  selector.addEventListener("pointerdown", (e) => {
    selector.setPointerCapture(e.pointerId);
    dragging = true;
    startPt = pointerPos(e);
    selBox = { x:startPt.x, y:startPt.y, w:1, h:1 };
    drawSelection();
  });

  selector.addEventListener("pointermove", (e) => {
    if(!dragging) return;
    const p = pointerPos(e);
    const x1 = startPt.x, y1 = startPt.y;
    const x2 = p.x, y2 = p.y;

    const x = Math.min(x1,x2);
    const y = Math.min(y1,y2);
    const w = Math.abs(x2-x1);
    const h = Math.abs(y2-y1);

    selBox = { x, y, w, h };
    drawSelection();
  });

  selector.addEventListener("pointerup", () => {
    dragging = false;
    // enforce min size
    if(selBox && (selBox.w < 20 || selBox.h < 20)) selBox = null;
    drawSelection();
    updateAvatarPreview();
  });

  // ---------- Flappy game ----------
  const STATE = { READY:"READY", RUNNING:"RUNNING", OVER:"OVER" };
  let state = STATE.READY;

  const bird = {
    x: 0, y: 0,
    r: 22,
    vy: 0,
  };

  let score = 0;
  let best = 0;

  const pipes = [];
  const pipe = {
    w: 78,
    gap: 180,
    speed: 3.2,
    spawnEvery: 1400, // ms
    lastSpawn: 0
  };

  function resetGame(){
    const W = window.innerWidth, H = window.innerHeight;
    bird.x = Math.floor(W*0.28);
    bird.y = Math.floor(H*0.45);
    bird.vy = 0;

    pipes.length = 0;
    score = 0;
    best = getUserBest(usernameInput.value.trim());
    hudRight.textContent = `Score: 0 | Best: ${best}`;
    state = STATE.READY;
  }

  function getUserBest(user){
    if(!user) return 0;
    const scores = loadScores();
    return scores[user] || 0;
  }

  function spawnPipe(){
    const H = window.innerHeight;
    const marginTop = 80;
    const marginBottom = 120;
    const usable = H - marginTop - marginBottom;
    const center = marginTop + Math.random() * usable;
    const gap = clamp(pipe.gap, 140, 260);

    const topH = clamp(center - gap/2, 40, H-200);
    const bottomY = topH + gap;

    pipes.push({
      x: window.innerWidth + 40,
      topH,
      bottomY,
      passed:false
    });
  }

  function flap(){
    if(state === STATE.OVER) return;
    if(state === STATE.READY) state = STATE.RUNNING;
    bird.vy = -8.5;
  }

  window.addEventListener("pointerdown", (e) => {
    // prevent clicking inside modal from flapping before start
    if(!setupOverlay.classList.contains("hidden")) return;
    if(!gameOverOverlay.classList.contains("hidden")) return;
    flap();
  });

  // ---------- Drawing ----------
  function drawPipes(){
    for(const p of pipes){
      // pipe color blocks
      g.fillStyle = "rgba(255,255,255,.12)";
      // top
      g.fillRect(p.x, 0, pipe.w, p.topH);
      // bottom
      g.fillRect(p.x, p.bottomY, pipe.w, window.innerHeight - p.bottomY);

      // pipe lip
      g.fillStyle = "rgba(255,255,255,.18)";
      g.fillRect(p.x-4, p.topH-16, pipe.w+8, 16);
      g.fillRect(p.x-4, p.bottomY, pipe.w+8, 16);
    }
  }

  function drawBird(){
    // draw avatar circle from avatarCanvas
    const size = bird.r*2;
    g.save();
    g.beginPath();
    g.arc(bird.x, bird.y, bird.r, 0, Math.PI*2);
    g.clip();

    // if avatar preview exists, draw it; else draw placeholder
    if(selBox){
      g.drawImage(avatarCanvas, bird.x-bird.r, bird.y-bird.r, size, size);
    } else {
      g.fillStyle = "rgba(255,255,255,.85)";
      g.fillRect(bird.x-bird.r, bird.y-bird.r, size, size);
    }
    g.restore();

    // outline
    g.strokeStyle = "rgba(255,255,255,.35)";
    g.lineWidth = 2;
    g.beginPath();
    g.arc(bird.x, bird.y, bird.r, 0, Math.PI*2);
    g.stroke();
  }

  function drawScore(){
    g.save();
    g.fillStyle = "rgba(255,255,255,.92)";
    g.font = "bold 40px system-ui";
    g.textAlign = "center";
    g.textBaseline = "top";
    g.fillText(String(score), window.innerWidth/2, 18);
    g.restore();
  }

  function hitPipe(p){
    // circle-rect collision approximation
    const cx = bird.x, cy = bird.y, r = bird.r;
    const rx = p.x, rw = pipe.w;

    // Top rect: (rx,0,rw,topH)
    const topHit = circleRect(cx,cy,r, rx,0, rw,p.topH);
    // Bottom rect: (rx,bottomY,rw,H-bottomY)
    const botHit = circleRect(cx,cy,r, rx,p.bottomY, rw, window.innerHeight - p.bottomY);
    return topHit || botHit;
  }

  function circleRect(cx,cy,r, rx,ry,rw,rh){
    const nearestX = clamp(cx, rx, rx+rw);
    const nearestY = clamp(cy, ry, ry+rh);
    const dx = cx - nearestX;
    const dy = cy - nearestY;
    return (dx*dx + dy*dy) <= r*r;
  }

  // ---------- Game loop ----------
  let lastT = performance.now();
  function tick(t){
    const dt = t - lastT;
    lastT = t;

    // clear
    g.clearRect(0,0,window.innerWidth, window.innerHeight);

    // background subtle stripes
    g.save();
    g.globalAlpha = 0.06;
    for(let x=0; x<window.innerWidth; x+=70){
      g.fillStyle = "#ffffff";
      g.fillRect(x,0,35,window.innerHeight);
    }
    g.restore();

    if(state === STATE.RUNNING){
      // physics
      bird.vy += 0.5;
      bird.y += bird.vy;

      // spawn pipes
      pipe.lastSpawn += dt;
      if(pipe.lastSpawn >= pipe.spawnEvery){
        pipe.lastSpawn = 0;
        spawnPipe();
      }

      // move pipes
      for(const p of pipes){
        p.x -= pipe.speed;
        if(!p.passed && p.x + pipe.w < bird.x){
          p.passed = true;
          score += 1;
          hudRight.textContent = `Score: ${score} | Best: ${best}`;
        }
      }

      // cleanup offscreen
      while(pipes.length && pipes[0].x + pipe.w < -20) pipes.shift();

      // collisions with bounds
      if(bird.y - bird.r < 0) { bird.y = bird.r; bird.vy = 0; }
      if(bird.y + bird.r > window.innerHeight){
        endGame();
      }

      // collisions with pipes
      for(const p of pipes){
        if(hitPipe(p)){
          endGame();
          break;
        }
      }
    }

    // draw everything
    drawPipes();
    drawBird();
    drawScore();

    requestAnimationFrame(tick);
  }

  function endGame(){
    state = STATE.OVER;

    const user = usernameInput.value.trim();
    const scores = saveBest(user, score);
    best = scores[user] || best;

    const sorted = Object.entries(scores).sort((a,b)=>b[1]-a[1]);
    const rank = sorted.findIndex(([u]) => u === user) + 1;
    const total = sorted.length;

    rankText.textContent = `Your rank: #${rank} of ${total}. Your score: ${score}. Best: ${best}.`;

    lbBox.innerHTML = "";
    const top = sorted.slice(0,10);
    top.forEach(([u, s], i) => {
      const div = document.createElement("div");
      div.className = "lbItem";
      div.innerHTML = `<span>#${i+1} ${escapeHtml(u)}</span><span>${s}</span>`;
      lbBox.appendChild(div);
    });

    gameOverOverlay.classList.remove("hidden");
  }

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  // ---------- Start handling ----------
  startBtn.addEventListener("click", () => {
    setupError.textContent = "";

    const user = usernameInput.value.trim();
    if(!user){
      setupError.textContent = "Username is required.";
      return;
    }
    if(!selBox){
      setupError.textContent = "Draw a box over your face on the photo first.";
      return;
    }
    // sanity: selection must have area
    if(selBox.w < 20 || selBox.h < 20){
      setupError.textContent = "Selection box is too small. Drag a bigger box.";
      return;
    }

    // update HUD and hide overlay
    hudLeft.textContent = `User: ${user}`;
    best = getUserBest(user);
    hudRight.textContent = `Score: 0 | Best: ${best}`;

    setupOverlay.classList.add("hidden");
    resetGame();
  });

  playAgainBtn.addEventListener("click", () => {
    gameOverOverlay.classList.add("hidden");
    resetGame();
    state = STATE.READY; // wait for first flap
  });

  // ---------- Image load ----------
  familyImg.addEventListener("load", () => {
    resizeSelector();
    updateAvatarPreview();
  });
  familyImg.addEventListener("error", () => {
    setupError.textContent = "Could not load family photo. Make sure docs/family-photo-123.jpg exists and is committed.";
  });

  // Initial
  resizeSelector();
  updateAvatarPreview();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
