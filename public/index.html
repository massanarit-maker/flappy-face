<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Face</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #0b1220;
      color: #e6edf3;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      padding: 14px;
      overflow: auto; /* default */
    }

    /* App-like playing mode: no page scroll, everything fits */
    body.playing {
      overflow: hidden;
      padding: 10px;
    }

    .wrap {
      width: 100%;
      max-width: 980px;

      /* Key change: make the layout fit the screen height */
      height: calc(100vh - 20px);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .topbar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between; }
    h1 { margin:0; font-size:28px; }
    .sub { opacity:0.85; font-size:14px; margin-top:4px; }

    .pill {
      display:inline-flex; flex-wrap:wrap; gap:10px; align-items:center;
      background:#111a2e; border:1px solid #22304f; border-radius:999px;
      padding:8px 12px; font-weight:600; font-size:14px;
    }

    .panel { background:#111a2e; border:1px solid #22304f; border-radius:12px; padding:12px; }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content: space-between; }

    .btn {
      padding:10px 14px; font-size:14px; font-weight:700;
      border-radius:10px; border:1px solid #22304f;
      background:#16233f; color:#e6edf3; cursor:pointer;
    }
    .btn:hover { filter:brightness(1.1); }
    .btn:disabled { opacity:0.55; cursor:not-allowed; }

    #status {
      margin-top:10px; padding:10px 12px; background:#0b1220;
      border-radius:10px; border:1px solid #22304f; min-height:42px;
      display:flex; align-items:center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px; overflow-x:auto; white-space:nowrap;
    }

    /* Game area must stretch to fill remaining height */
    .gameShell {
      background:#0b1220;
      border:1px solid #22304f;
      border-radius:12px;
      padding:12px;

      flex: 1;                 /* fills available vertical space */
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;           /* IMPORTANT for flex children sizing */
    }

    canvas {
      width:100%;
      height: 100%;            /* fills gameShell remaining height */
      display:block;
      background: linear-gradient(#0e1a33, #08101f);
      border-radius:10px; border:1px solid #22304f;
      touch-action: manipulation;
      flex: 1;
      min-height: 0;
    }

    .help { opacity:0.85; font-size:14px; line-height:1.4; }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      padding:2px 6px; border:1px solid #22304f; border-radius:6px; background:#0b1220;
    }

    /* Hide non-game panels while playing so everything fits */
    body.playing #controlPanel { display: none; }
    body.playing #pageLeaderboard { display: none; }

    /* Leaderboard (page section, hidden during play) */
    .lbTitle { font-size:16px; font-weight:800; margin:0 0 10px 0; }
    .lbBox {
      background:#0b1220; border:1px solid #22304f; border-radius:10px; padding:10px 12px;
    }
    .lbRow {
      display:flex; justify-content:space-between; gap:10px;
      padding:8px 0; border-bottom:1px solid rgba(34,48,79,0.5);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:13px;
    }
    .lbRow:last-child { border-bottom:none; }
    .lbRank { width: 34px; opacity: 0.85; }
    .lbName { flex: 1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .lbScore { width: 70px; text-align:right; font-weight: 800; }
    .small { font-size:12px; opacity:0.85; line-height:1.35; }

    /* Overlay */
    .overlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.70);
      display:flex; justify-content:center; align-items:center; padding:12px;
      z-index:9999;
    }
    .modal {
      width:100%; max-width:860px;
      background:#111a2e; border:1px solid #22304f; border-radius:14px;
      padding:14px;
      max-height: calc(100vh - 24px);
      overflow:auto;
    }
    .modal h2 { margin:0 0 8px 0; font-size:20px; }
    .error { color:#ff7b72; font-weight:800; }

    .grid {
      display:grid; grid-template-columns: 1.4fr 0.6fr; gap:12px; align-items:start;
    }
    @media (max-width: 820px) {
      .grid { grid-template-columns: 1fr; }
    }

    .field { display:flex; flex-direction:column; gap:6px; }
    label { font-size:12px; opacity:0.85; }
    input[type="text"] {
      background:#0b1220; color:#e6edf3; border:1px solid #22304f;
      border-radius:10px; padding:10px 12px; font-size:14px;
    }

    .photoWrap {
      position:relative;
      border-radius:12px;
      border:1px solid #22304f;
      overflow:hidden;
      background:#0b1220;
    }
    .photoWrap img {
      width:100%;
      height:auto;
      display:block;
      user-select:none;
      -webkit-user-drag:none;
    }
    .photoWrap canvas {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border:none;
      border-radius:0;
      background:transparent;
      touch-action: none;
    }

    .previewBox {
      display:flex; align-items:center; gap:10px;
      padding:10px; border-radius:12px; border:1px solid #22304f;
      background:#0b1220;
    }
    .previewImg {
      width:56px; height:56px; border-radius:50%;
      border:1px solid #22304f; object-fit:cover; background:#0b1220;
    }

    /* Game Over Popup leaderboard */
    .goBox {
      background:#0b1220;
      border:1px solid #22304f;
      border-radius:12px;
      padding:12px;
      margin-top:10px;
    }
    .goTitle { font-size:18px; font-weight:900; margin:0 0 8px 0; }
    .goLine {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:13px;
      opacity:0.92;
      margin:6px 0;
    }
    .goLb {
      margin-top:10px;
      border:1px solid #22304f;
      border-radius:10px;
      background:#111a2e;
      overflow:hidden;
    }
    .goLbRow {
      display:flex;
      gap:10px;
      justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid rgba(34,48,79,0.55);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:13px;
    }
    .goLbRow:last-child { border-bottom:none; }
    .goLbRank { width:44px; opacity:0.9; }
    .goLbName { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .goLbScore { width:80px; text-align:right; font-weight:900; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Flappy Face</h1>
        <div class="sub">Family contest mode. Leaderboard is global and saved for everyone.</div>
      </div>
      <div class="pill">
        <span>User:</span> <span id="who">Not set</span>
        <span style="opacity:0.6">|</span>
        <span>Score:</span> <span id="score">0</span>
        <span style="opacity:0.6">|</span>
        <span>Best:</span> <span id="best">0</span>
        <span style="opacity:0.6">|</span>
        <span>Debug:</span> <span id="dbg">idle</span>
      </div>
    </div>

    <div class="panel" id="controlPanel">
      <div class="row">
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button id="check" class="btn" type="button">Check /healthz</button>
          <button id="restart" class="btn" type="button" disabled>Try Again</button>
          <button id="changePlayer" class="btn" type="button">Change Player</button>
        </div>
        <span class="small" style="opacity:0.75;">Leaderboard shows at Game Over</span>
      </div>
      <div id="status">Not checked yet</div>
    </div>

    <div class="gameShell">
      <canvas id="game" width="420" height="640" aria-label="Flappy game canvas"></canvas>
      <div class="help">
        Controls: <span class="kbd">Tap</span> / <span class="kbd">Click</span> to flap. If you crash, a Top 10 leaderboard pop-up will appear.
      </div>
    </div>

    <div class="panel" id="pageLeaderboard">
      <div class="lbTitle">Leaderboard (best score per username)</div>
      <div class="lbBox" id="lbBox">
        <div class="small" id="lbMsg">Loading…</div>
      </div>
      <div class="small" style="margin-top:10px;">
        This section is hidden during gameplay so the game behaves like an app (no scroll needed).
      </div>
    </div>
  </div>

  <!-- Player Select Overlay -->
  <div class="overlay" id="overlay">
    <div class="modal">
      <h2>Pick Your Face, Enter Your Username</h2>
      <div class="small" style="margin-bottom:10px;">
        Drag a box over your face in the family photo. On iPhone, press and drag with your finger.
        Then type your username and press Start.
      </div>

      <div class="grid">
        <div>
          <div class="photoWrap">
            <img id="familyPhoto" src="/family.jpg" alt="Family Photo" />
            <canvas id="selector"></canvas>
          </div>
          <div class="small" style="margin-top:8px;">
            Tip: If you already played before with the same username, your saved face will load automatically.
          </div>
        </div>

        <div class="field">
          <label for="username">Username (required)</label>
          <input id="username" type="text" placeholder="Type a username" autocomplete="off" />

          <div class="previewBox" style="margin-top:6px;">
            <img id="preview" class="previewImg" alt="Avatar preview" />
            <div>
              <div class="small" id="previewText">No saved face yet. Select your face on the photo.</div>
              <div class="small" id="startError" style="margin-top:6px;"></div>
            </div>
          </div>

          <div class="row" style="margin-top:10px; justify-content:flex-start;">
            <button id="startBtn" class="btn" type="button">Start Game</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Over Leaderboard Popup -->
  <div class="overlay" id="gameOverOverlay" style="display:none;">
    <div class="modal" style="max-width:520px;">
      <div class="goBox">
        <div class="goTitle">Game Over</div>
        <div class="goLine" id="goScoreLine">Your score: 0</div>
        <div class="goLine" id="goRankLine">Your rank: loading…</div>

        <div class="small" style="margin-top:10px; opacity:0.85;">
          Top 10 leaderboard:
        </div>
        <div class="goLb" id="goTop10">
          <div class="goLbRow">
            <div class="goLbRank">#</div>
            <div class="goLbName">Loading…</div>
            <div class="goLbScore"></div>
          </div>
        </div>

        <div class="row" style="margin-top:12px; justify-content:flex-start;">
          <button id="goTryAgain" class="btn" type="button">Try Again</button>
          <button id="goChangePlayer" class="btn" type="button">Change Player</button>
          <button id="goClose" class="btn" type="button">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const dbgEl = document.getElementById("dbg");
    const statusEl = document.getElementById("status");

    document.getElementById("check").onclick = async () => {
      statusEl.textContent = "Checking...";
      try {
        const res = await fetch("/healthz", { cache: "no-store" });
        const data = await res.json();
        statusEl.textContent = "OK: " + JSON.stringify(data);
      } catch (e) {
        statusEl.textContent = "ERROR: Server not responding";
      }
    };

    const whoEl = document.getElementById("who");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const restartBtn = document.getElementById("restart");
    const changePlayerBtn = document.getElementById("changePlayer");

    const lbBox = document.getElementById("lbBox");

    const overlay = document.getElementById("overlay");
    const gameOverOverlay = document.getElementById("gameOverOverlay");

    const goScoreLine = document.getElementById("goScoreLine");
    const goRankLine = document.getElementById("goRankLine");
    const goTop10 = document.getElementById("goTop10");
    const goTryAgain = document.getElementById("goTryAgain");
    const goChangePlayer = document.getElementById("goChangePlayer");
    const goClose = document.getElementById("goClose");

    const usernameInput = document.getElementById("username");
    const startBtn = document.getElementById("startBtn");
    const startError = document.getElementById("startError");
    const previewImg = document.getElementById("preview");
    const previewText = document.getElementById("previewText");

    const familyImg = document.getElementById("familyPhoto");
    const selCanvas = document.getElementById("selector");
    const selCtx = selCanvas.getContext("2d");

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const G = 1800;
    const FLAP_VY = -520;
    const PIPE_SPEED = 220;
    const PIPE_WIDTH = 74;
    const PIPE_GAP = 170;
    const PIPE_SPAWN_SEC = 1.25;
    const FLOOR_H = 80;

    let selectedUsername = "";
    let selectedFaceUrl = null;

    let bird = { x: 120, y: canvas.height * 0.45, r: 18, vy: 0 };
    let pipes = [];
    let score = 0;
    let best = 0;
    let running = false;
    let gameOver = false;
    let gameOverPrev = false;
    let lastTs = 0;
    let spawnT = 0;

    let scoreSavedForThisRun = false;

    let myRank = null;
    let totalPlayers = null;
    let rankLoading = false;

    let faceImg = new Image();
    let faceLoaded = false;
    let faceSrcActive = "";

    function setPlayingMode(on) {
      if (on) document.body.classList.add("playing");
      else document.body.classList.remove("playing");
    }

    function setFaceFromUrl(url) {
      faceLoaded = false;
      faceSrcActive = url || "";
      if (!url) return;
      faceImg = new Image();
      faceImg.onload = () => { faceLoaded = true; };
      faceImg.onerror = () => { faceLoaded = false; };
      faceImg.src = url + `?t=${Date.now()}`;
    }

    function setGameEnabled(enabled) {
      restartBtn.disabled = !enabled;
    }

    function hideGameOverPopup() {
      gameOverOverlay.style.display = "none";
    }

    async function showGameOverPopup() {
      goScoreLine.textContent = `Your score: ${score}`;

      if (rankLoading) goRankLine.textContent = "Your rank: loading…";
      else if (myRank && totalPlayers) goRankLine.textContent = `Your rank: #${myRank} of ${totalPlayers}`;
      else if (totalPlayers === 0) goRankLine.textContent = "Your rank: #1 of 1";
      else goRankLine.textContent = "Your rank: unavailable";

      goTop10.innerHTML = `
        <div class="goLbRow">
          <div class="goLbRank">#</div>
          <div class="goLbName">Loading…</div>
          <div class="goLbScore"></div>
        </div>
      `;

      try {
        const res = await fetch("/api/leaderboard?limit=10", { cache: "no-store" });
        const data = await res.json();
        if (data && data.ok && Array.isArray(data.rows) && data.rows.length > 0) {
          goTop10.innerHTML = data.rows.map((r, i) => `
            <div class="goLbRow">
              <div class="goLbRank">#${i + 1}</div>
              <div class="goLbName">${escapeHtml(r.username)}</div>
              <div class="goLbScore">${r.best}</div>
            </div>
          `).join("");
        } else {
          goTop10.innerHTML = `
            <div class="goLbRow">
              <div class="goLbRank">#</div>
              <div class="goLbName">No scores yet</div>
              <div class="goLbScore"></div>
            </div>
          `;
        }
      } catch (e) {
        goTop10.innerHTML = `
          <div class="goLbRow">
            <div class="goLbRank">#</div>
            <div class="goLbName">Could not load Top 10</div>
            <div class="goLbScore"></div>
          </div>
        `;
      }

      gameOverOverlay.style.display = "flex";
    }

    function resetGame() {
      setFaceFromUrl(selectedFaceUrl);

      bird = { x: 120, y: canvas.height * 0.45, r: 18, vy: 0 };
      pipes = [];
      score = 0;
      running = true;
      gameOver = false;
      gameOverPrev = false;
      spawnT = 0;
      lastTs = 0;

      scoreSavedForThisRun = false;
      myRank = null;
      totalPlayers = null;
      rankLoading = false;

      scoreEl.textContent = "0";
      dbgEl.textContent = "running";

      hideGameOverPopup();
      setPlayingMode(true);
    }

    function flap() {
      if (!running || gameOver) return;
      bird.vy = FLAP_VY;
    }

    function addPipe() {
      const topMargin = 60;
      const bottomMargin = FLOOR_H + 60;
      const minCenter = topMargin + PIPE_GAP / 2;
      const maxCenter = canvas.height - bottomMargin - PIPE_GAP / 2;
      const centerY = minCenter + Math.random() * (maxCenter - minCenter);

      const topH = centerY - PIPE_GAP / 2;
      const bottomY = centerY + PIPE_GAP / 2;
      const bottomH = canvas.height - bottomY - FLOOR_H;

      pipes.push({ x: canvas.width + 20, w: PIPE_WIDTH, topH, bottomY, bottomH, passed: false });
    }

    function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx * dx + dy * dy) <= (cr * cr);
    }

    async function loadRank() {
      if (!selectedUsername) return;
      rankLoading = true;
      try {
        const res = await fetch(`/api/rank?username=${encodeURIComponent(selectedUsername)}`, { cache: "no-store" });
        const data = await res.json();
        if (data && data.ok) {
          myRank = data.rank;
          totalPlayers = data.total;
        }
      } catch (e) {
      } finally {
        rankLoading = false;
      }
    }

    async function saveScoreOnce() {
      if (!selectedUsername) return;
      if (scoreSavedForThisRun) return;
      scoreSavedForThisRun = true;

      try {
        const res = await fetch("/api/score", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username: selectedUsername, score })
        });
        const data = await res.json();
        if (data && data.ok) {
          dbgEl.textContent = "score saved";
          await loadRank();
          await showGameOverPopup();
          await loadPageLeaderboard();
        } else {
          dbgEl.textContent = "score save failed";
          await showGameOverPopup();
        }
      } catch (e) {
        dbgEl.textContent = "score save error";
        await showGameOverPopup();
      }
    }

    function update(dt) {
      bird.vy += G * dt;
      bird.y += bird.vy * dt;

      if (bird.y - bird.r < 0) { bird.y = bird.r; bird.vy = 0; }
      if (bird.y + bird.r > canvas.height - FLOOR_H) { bird.y = canvas.height - FLOOR_H - bird.r; gameOver = true; }

      spawnT += dt;
      if (spawnT >= PIPE_SPAWN_SEC) { spawnT = 0; addPipe(); }

      for (const p of pipes) {
        p.x -= PIPE_SPEED * dt;

        if (!p.passed && p.x + p.w < bird.x - bird.r) {
          p.passed = true;
          score += 1;
          scoreEl.textContent = String(score);
          if (score > best) { best = score; bestEl.textContent = String(best); }
        }
      }

      pipes = pipes.filter(p => p.x + p.w > -50);

      for (const p of pipes) {
        if (circleRectCollide(bird.x, bird.y, bird.r, p.x, 0, p.w, p.topH)) gameOver = true;
        if (circleRectCollide(bird.x, bird.y, bird.r, p.x, p.bottomY, p.w, p.bottomH)) gameOver = true;
      }
    }

    function drawBirdWithFace() {
      ctx.save();
      ctx.beginPath();
      ctx.arc(bird.x, bird.y, bird.r, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = "#7cc4ff";
      ctx.fill();
      ctx.clip();

      if (faceSrcActive && faceLoaded) {
        const size = bird.r * 2;
        ctx.drawImage(faceImg, bird.x - bird.r, bird.y - bird.r, size, size);
      } else {
        ctx.fillStyle = "#0b1220";
        ctx.fillRect(bird.x - bird.r, bird.y - bird.r, bird.r * 2, bird.r * 2);
        ctx.beginPath();
        ctx.fillStyle = "#e6edf3";
        ctx.arc(bird.x + 6, bird.y - 4, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      ctx.beginPath();
      ctx.strokeStyle = "#22304f";
      ctx.lineWidth = 2;
      ctx.arc(bird.x, bird.y, bird.r, 0, Math.PI * 2);
      ctx.stroke();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "#7cc4ff";
      for (let i = 0; i < 8; i++) ctx.fillRect(i * 70, 0, 35, canvas.height);
      ctx.globalAlpha = 1;

      for (const p of pipes) {
        ctx.fillStyle = "#3fb950";
        ctx.fillRect(p.x, 0, p.w, p.topH);
        ctx.fillRect(p.x, p.bottomY, p.w, p.bottomH);

        ctx.fillStyle = "#2ea043";
        ctx.fillRect(p.x - 6, p.topH - 18, p.w + 12, 18);
        ctx.fillRect(p.x - 6, p.bottomY, p.w + 12, 18);
      }

      ctx.fillStyle = "#0a0f1a";
      ctx.fillRect(0, canvas.height - FLOOR_H, canvas.width, FLOOR_H);
      ctx.fillStyle = "#22304f";
      ctx.fillRect(0, canvas.height - FLOOR_H, canvas.width, 2);

      if (selectedUsername) drawBirdWithFace();

      if (!selectedUsername) {
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#e6edf3";
        ctx.font = "bold 18px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Pick your face + username to start", canvas.width / 2, canvas.height / 2);
      } else if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#e6edf3";
        ctx.font = "bold 36px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 30);
        ctx.font = "16px Arial";
        ctx.fillText("Leaderboard pop-up shown", canvas.width / 2, canvas.height / 2 + 10);
      } else if (score === 0 && pipes.length === 0) {
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#e6edf3";
        ctx.font = "bold 20px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Tap / Click to Flap", canvas.width / 2, canvas.height / 2);
      }
    }

    function loop(ts) {
      if (!lastTs) lastTs = ts;
      const dt = Math.min(0.033, (ts - lastTs) / 1000);
      lastTs = ts;

      if (selectedUsername && running && !gameOver) update(dt);

      if (selectedUsername) {
        if (!gameOverPrev && gameOver) {
          dbgEl.textContent = "game over";
          saveScoreOnce();
        }
        gameOverPrev = gameOver;
      }

      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") { e.preventDefault(); flap(); }
    });
    canvas.addEventListener("pointerdown", () => flap());

    restartBtn.addEventListener("click", () => {
      if (!selectedUsername) return;
      resetGame();
      setTimeout(() => flap(), 50);
    });

    goTryAgain.addEventListener("click", () => {
      hideGameOverPopup();
      restartBtn.click();
    });
    goChangePlayer.addEventListener("click", () => {
      hideGameOverPopup();
      setPlayingMode(false);
      overlay.style.display = "flex";
      setGameEnabled(false);
      dbgEl.textContent = "overlay";
    });
    goClose.addEventListener("click", () => {
      hideGameOverPopup();
    });

    changePlayerBtn.addEventListener("click", () => {
      hideGameOverPopup();
      overlay.style.display = "flex";
      setPlayingMode(false);
      setGameEnabled(false);
      dbgEl.textContent = "overlay";
    });

    // Face selection UI
    let sel = null;
    let dragging = false;

    function resizeSelectorCanvas() {
      const rect = familyImg.getBoundingClientRect();
      selCanvas.width = Math.max(1, Math.floor(rect.width));
      selCanvas.height = Math.max(1, Math.floor(rect.height));
      drawSelection();
    }

    function drawSelection() {
      selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);
      if (!sel) return;

      const x = Math.min(sel.x0, sel.x1);
      const y = Math.min(sel.y0, sel.y1);
      const w = Math.abs(sel.x1 - sel.x0);
      const h = Math.abs(sel.y1 - sel.y0);

      selCtx.fillStyle = "rgba(0,0,0,0.25)";
      selCtx.fillRect(0, 0, selCanvas.width, selCanvas.height);

      selCtx.clearRect(x, y, w, h);

      selCtx.strokeStyle = "rgba(255,255,255,0.95)";
      selCtx.lineWidth = 2;
      selCtx.strokeRect(x + 0.5, y + 0.5, w, h);
    }

    function pointerPos(ev) {
      const r = selCanvas.getBoundingClientRect();
      return {
        x: Math.max(0, Math.min(r.width, ev.clientX - r.left)),
        y: Math.max(0, Math.min(r.height, ev.clientY - r.top))
      };
    }

    selCanvas.addEventListener("pointerdown", (ev) => {
      selCanvas.setPointerCapture(ev.pointerId);
      dragging = true;
      const p = pointerPos(ev);
      sel = { x0: p.x, y0: p.y, x1: p.x, y1: p.y };
      drawSelection();
      dbgEl.textContent = "selecting";
    });

    selCanvas.addEventListener("pointermove", (ev) => {
      if (!dragging || !sel) return;
      const p = pointerPos(ev);
      sel.x1 = p.x;
      sel.y1 = p.y;
      drawSelection();
    });

    selCanvas.addEventListener("pointerup", () => {
      dragging = false;
      if (!sel) return;
      drawSelection();
      dbgEl.textContent = "selected";
    });

    window.addEventListener("resize", () => resizeSelectorCanvas());
    familyImg.addEventListener("load", () => { resizeSelectorCanvas(); dbgEl.textContent = "photo loaded"; });

    async function loadExistingAvatar(username) {
      try {
        const res = await fetch(`/api/avatar?username=${encodeURIComponent(username)}`, { cache: "no-store" });
        const data = await res.json();
        if (data.ok && data.avatarUrl) return data.avatarUrl;
      } catch (e) {}
      return null;
    }

    let usernameTimer = null;
    usernameInput.addEventListener("input", () => {
      clearTimeout(usernameTimer);
      usernameTimer = setTimeout(async () => {
        const name = (usernameInput.value || "").trim();
        if (!name) {
          previewImg.removeAttribute("src");
          previewText.textContent = "No saved face yet. Select your face on the photo.";
          return;
        }
        const url = await loadExistingAvatar(name);
        if (url) {
          previewImg.src = url + `?t=${Date.now()}`;
          previewText.textContent = "Saved face found for this username.";
        } else {
          previewImg.removeAttribute("src");
          previewText.textContent = "No saved face yet. Select your face on the photo.";
        }
      }, 300);
    });

    function cropSelectionToBlob() {
      if (!sel) return null;

      const dispW = selCanvas.width;
      const dispH = selCanvas.height;
      const natW = familyImg.naturalWidth;
      const natH = familyImg.naturalHeight;

      if (!dispW || !dispH || !natW || !natH) return null;

      const x = Math.min(sel.x0, sel.x1);
      const y = Math.min(sel.y0, sel.y1);
      const w = Math.abs(sel.x1 - sel.x0);
      const h = Math.abs(sel.y1 - sel.y0);

      if (w < 20 || h < 20) return null;

      const scaleX = natW / dispW;
      const scaleY = natH / dispH;

      const sx = Math.floor(x * scaleX);
      const sy = Math.floor(y * scaleY);
      const sw = Math.floor(w * scaleX);
      const sh = Math.floor(h * scaleY);

      const outSize = 256;
      const out = document.createElement("canvas");
      out.width = outSize;
      out.height = outSize;
      const octx = out.getContext("2d");

      octx.fillStyle = "#000";
      octx.fillRect(0, 0, outSize, outSize);
      octx.drawImage(familyImg, sx, sy, sw, sh, 0, 0, outSize, outSize);

      return new Promise((resolve) => {
        out.toBlob((blob) => resolve(blob), "image/png", 0.92);
      });
    }

    async function uploadAvatar(username, blob) {
      const form = new FormData();
      form.append("username", username);
      form.append("avatar", blob, "avatar.png");

      const res = await fetch("/api/upload-avatar", { method: "POST", body: form });
      const data = await res.json();
      if (!res.ok || !data.ok) throw new Error(data.error || "Upload failed");
      return data.avatarUrl;
    }

    async function loadPageLeaderboard() {
      lbBox.innerHTML = `<div class="small">Loading…</div>`;
      try {
        const res = await fetch("/api/leaderboard?limit=20", { cache: "no-store" });
        const data = await res.json();
        if (!data.ok) throw new Error("bad response");

        if (!data.rows || data.rows.length === 0) {
          lbBox.innerHTML = `<div class="small">No scores yet. Play a round to create the first score.</div>`;
          return;
        }

        lbBox.innerHTML = data.rows.map((r, i) => `
          <div class="lbRow">
            <div class="lbRank">#${i + 1}</div>
            <div class="lbName">${escapeHtml(r.username)}</div>
            <div class="lbScore">${r.best}</div>
          </div>
        `).join("");
      } catch (e) {
        lbBox.innerHTML = `<div class="small">Could not load leaderboard.</div>`;
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    startBtn.addEventListener("click", async () => {
      startError.textContent = "";
      startError.classList.remove("error");

      const name = (usernameInput.value || "").trim();
      if (!name) {
        startError.textContent = "Username is required.";
        startError.classList.add("error");
        return;
      }

      dbgEl.textContent = "starting";

      let avatarUrl = await loadExistingAvatar(name);

      if (!avatarUrl) {
        const blob = await cropSelectionToBlob();
        if (!blob) {
          startError.textContent = "Select your face on the photo first (drag a box around it).";
          startError.classList.add("error");
          dbgEl.textContent = "need selection";
          return;
        }
        try {
          avatarUrl = await uploadAvatar(name, blob);
        } catch (e) {
          startError.textContent = "Could not save face: " + (e.message || "Upload error");
          startError.classList.add("error");
          dbgEl.textContent = "upload error";
          return;
        }
      }

      selectedUsername = name;
      selectedFaceUrl = avatarUrl;

      whoEl.textContent = selectedUsername;

      overlay.style.display = "none";
      setGameEnabled(true);
      setPlayingMode(true);
      resetGame();
      setTimeout(() => flap(), 50);

      dbgEl.textContent = "started";
      loadPageLeaderboard();
    });

    (function init() {
      best = 0;
      bestEl.textContent = "0";
      setGameEnabled(false);
      setPlayingMode(false);
      overlay.style.display = "flex";
      whoEl.textContent = "Not set";
      dbgEl.textContent = "ready";
      usernameInput.focus();
      loadPageLeaderboard();
    })();
  </script>
</body>
</html>
